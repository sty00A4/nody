; control flow
(def-global-inline @if $(:cond bool :case closure)
    #(do (? :cond :case #())))
(def-global-inline @if $(:cond bool :case closure :else closure)
    #(do (? :cond :case :else)))
; logic
(def-global @not $(v bool) #(? (bool v) false true))
(def-global @or $(a any b any) #(? (bool a) a b))
(def-global @and $(a any b any)
    #(? (bool a)
        (? (bool b)
            b
            false)
        false))
(def-global @xor $(a any b any)
    #(? (and a (not (bool b)))
        a
        (? (and b (not (bool a)))
            b
            false)))
; math
(def-global @sum $(nums (vec int)) #{
	(mut @res 0)
	(for @n nums
		#(set @res (+ res n)))
	(return res)
})
(def-global @sum $(nums (vec float)) #{
	(mut @res 0.0)
	(for @n nums
		#(set @res (+ res n)))
	(return res)
})
; stings
(def-global @concat $(strs str *) #{
	(mut @res "")
	(for @s strs
		#(set @res (+ res s)))
	(return res)
})
(def-global @concat $(strs (vec str)) #{
	(mut @res "")
	(for @s strs
		#(set @res (+ res s)))
	(return res)
})
(def-global @join $(sep str strs (vec str)) #{
	(mut @res "")
	(for @s strs
		#(set @res (+ res s sep)))
	(if (> (len strs) 0)
		#(set @res (res 0 (- (len res) (len sep)))))
	(return res)
})
(def-global @join $(sep str strs str *) #{
	(mut @res "")
	(for @s strs
		#(set @res (+ res s sep)))
	(if (> (len strs) 0)
		#(set @res (res 0 (- (len res) (len sep)))))
	(return res)
})